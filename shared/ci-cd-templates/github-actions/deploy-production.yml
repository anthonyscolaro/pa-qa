name: Deploy to Production

on:
  push:
    tags:
      - 'v*.*.*'  # Semantic versioning tags only
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (must be a tagged release)'
        required: true
        type: string
      bypass_approval:
        description: 'Bypass manual approval (emergency deployment)'
        required: false
        default: false
        type: boolean
      rollback_version:
        description: 'Version to rollback to (leave empty for new deployment)'
        required: false
        type: string
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary

concurrency:
  group: production-deployment
  cancel-in-progress: false  # Never cancel production deployments

env:
  ENVIRONMENT: production
  DEPLOYMENT_TIMEOUT: 1200  # 20 minutes for production
  HEALTH_CHECK_TIMEOUT: 600  # 10 minutes for health checks
  CANARY_PERCENTAGE: 10      # 10% traffic for canary deployments

jobs:
  pre-deployment-validation:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
      project-type: ${{ steps.detect.outputs.project-type }}
      version: ${{ steps.version.outputs.version }}
      is-rollback: ${{ steps.validation.outputs.is-rollback }}
      deployment-strategy: ${{ steps.validation.outputs.deployment-strategy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate deployment trigger
        run: |
          if [ "${{ github.event_name }}" == "push" ] && [[ ! "${{ github.ref }}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Production deployments only allowed from semantic version tags"
            exit 1
          fi
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -z "${{ github.event.inputs.version }}" ]; then
            echo "❌ Version is required for manual deployments"
            exit 1
          fi

      - name: Detect project type
        id: detect
        run: |
          if [ -f package.json ] && grep -q '"react"' package.json; then
            echo "project-type=react" >> $GITHUB_OUTPUT
          elif [ -f requirements.txt ] && grep -q 'fastapi' requirements.txt; then
            echo "project-type=fastapi" >> $GITHUB_OUTPUT
          elif [ -f wp-config.php ] || ([ -f style.css ] && grep -q 'Theme Name' style.css); then
            echo "project-type=wordpress" >> $GITHUB_OUTPUT
          else
            echo "project-type=generic" >> $GITHUB_OUTPUT
          fi

      - name: Determine version and deployment type
        id: version
        run: |
          if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
            echo "version=${{ github.event.inputs.rollback_version }}" >> $GITHUB_OUTPUT
            echo "🔄 Rollback deployment to version: ${{ github.event.inputs.rollback_version }}"
          elif [ -n "${{ github.event.inputs.version }}" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            version=${GITHUB_REF#refs/tags/}
            echo "version=$version" >> $GITHUB_OUTPUT
          fi

      - name: Validate version exists
        run: |
          version="${{ steps.version.outputs.version }}"
          
          # Check if tag exists
          if ! git rev-parse "$version" >/dev/null 2>&1; then
            echo "❌ Version $version does not exist as a git tag"
            exit 1
          fi
          
          echo "✅ Version $version validated"

      - name: Check staging deployment status
        if: github.event.inputs.rollback_version == ''
        run: |
          # Verify this version was successfully deployed to staging
          echo "🔍 Checking staging deployment status for version ${{ steps.version.outputs.version }}"
          
          # Call staging environment API to verify deployment
          staging_status=$(curl -s -f "${{ vars.STAGING_API_URL }}/health" | jq -r '.version // "unknown"' || echo "unknown")
          
          if [ "$staging_status" != "${{ steps.version.outputs.version }}" ]; then
            echo "⚠️  WARNING: Staging is running $staging_status, deploying ${{ steps.version.outputs.version }}"
            echo "This might indicate the version wasn't properly tested in staging"
          else
            echo "✅ Version ${{ steps.version.outputs.version }} verified in staging"
          fi

      - name: Run pre-deployment security checks
        run: |
          echo "🔒 Running production security validation..."
          
          # Check for any critical security vulnerabilities
          if [ -f .github/security-baseline.json ]; then
            echo "Validating against security baseline..."
            # Add security validation logic here
          fi
          
          # Ensure all secrets are properly configured
          required_secrets=("DATABASE_URL" "API_KEYS" "CERTIFICATES")
          for secret in "${required_secrets[@]}"; do
            if [ -z "${!secret}" ]; then
              echo "⚠️  WARNING: $secret not configured"
            fi
          done

      - name: Validate deployment window
        run: |
          # Check if we're in an allowed deployment window
          current_hour=$(date -u +%H)
          current_day=$(date -u +%u)  # 1-7, Monday is 1
          
          # Allow deployments Monday-Friday, 9 AM - 5 PM UTC (unless emergency)
          if [ "${{ github.event.inputs.bypass_approval }}" != "true" ]; then
            if [ $current_day -gt 5 ] || [ $current_hour -lt 9 ] || [ $current_hour -gt 17 ]; then
              echo "❌ Deployments outside business hours require emergency approval"
              echo "Current time: $(date -u) (UTC)"
              exit 1
            fi
          fi

      - name: Final validation
        id: validation
        run: |
          should_deploy="true"
          is_rollback="false"
          deployment_strategy="${{ github.event.inputs.deployment_strategy || 'rolling' }}"
          
          if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
            is_rollback="true"
            deployment_strategy="rolling"  # Rollbacks always use rolling strategy
          fi
          
          echo "should-deploy=$should_deploy" >> $GITHUB_OUTPUT
          echo "is-rollback=$is_rollback" >> $GITHUB_OUTPUT
          echo "deployment-strategy=$deployment_strategy" >> $GITHUB_OUTPUT

  # Manual approval step for production deployments
  approval:
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true' && github.event.inputs.bypass_approval != 'true'
    environment:
      name: production-approval
    steps:
      - name: Request deployment approval
        run: |
          echo "🔐 Production deployment requires manual approval"
          echo "Version: ${{ needs.pre-deployment-validation.outputs.version }}"
          echo "Project Type: ${{ needs.pre-deployment-validation.outputs.project-type }}"
          echo "Strategy: ${{ needs.pre-deployment-validation.outputs.deployment-strategy }}"
          echo "Is Rollback: ${{ needs.pre-deployment-validation.outputs.is-rollback }}"

  build-production-artifacts:
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, approval]
    if: always() && (needs.approval.result == 'success' || needs.approval.result == 'skipped') && needs.pre-deployment-validation.outputs.should-deploy == 'true'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      artifact-url: ${{ steps.build.outputs.artifact-url }}
    steps:
      - name: Checkout specific version
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.pre-deployment-validation.outputs.version }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.CONTAINER_REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build production React application
        if: needs.pre-deployment-validation.outputs.project-type == 'react'
        run: |
          # Setup Node.js production build
          node_version=$(cat .nvmrc 2>/dev/null || echo "20")
          curl -fsSL https://deb.nodesource.com/setup_${node_version}.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Production build with optimizations
          export NODE_ENV=production
          npm ci --production=false
          npm run build
          npm run optimize  # Additional optimization step if available
          
          # Create production package
          tar -czf production-build-${{ needs.pre-deployment-validation.outputs.version }}.tar.gz build/

      - name: Build production FastAPI image
        if: needs.pre-deployment-validation.outputs.project-type == 'fastapi'
        id: build
        run: |
          # Multi-stage production build
          docker build \
            --target production \
            --tag ${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:${{ needs.pre-deployment-validation.outputs.version }} \
            --tag ${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:production-latest \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=$(git rev-parse HEAD) \
            --build-arg VERSION=${{ needs.pre-deployment-validation.outputs.version }} \
            --build-arg ENVIRONMENT=production \
            --platform linux/amd64 \
            .
          
          # Security scan the production image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image \
            --exit-code 1 \
            --severity HIGH,CRITICAL \
            ${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:${{ needs.pre-deployment-validation.outputs.version }}
          
          # Push production images
          docker push ${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:${{ needs.pre-deployment-validation.outputs.version }}
          docker push ${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:production-latest
          
          echo "image-tag=${{ vars.CONTAINER_REGISTRY }}/pa-qa-app:${{ needs.pre-deployment-validation.outputs.version }}" >> $GITHUB_OUTPUT

      - name: Build production WordPress package
        if: needs.pre-deployment-validation.outputs.project-type == 'wordpress'
        run: |
          # Production WordPress build
          if [ -f composer.json ]; then
            composer install --no-dev --optimize-autoloader --classmap-authoritative
          fi
          
          if [ -f package.json ]; then
            npm ci --production
            npm run build:production
          fi
          
          # Create optimized production package
          zip -r wordpress-production-${{ needs.pre-deployment-validation.outputs.version }}.zip . \
            -x "node_modules/*" "tests/*" ".git/*" "*.md" ".github/*" "dev-*" "*.log"

      - name: Upload production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-package-${{ needs.pre-deployment-validation.outputs.version }}
          path: |
            production-build-${{ needs.pre-deployment-validation.outputs.version }}.tar.gz
            wordpress-production-${{ needs.pre-deployment-validation.outputs.version }}.zip
          retention-days: 90  # Keep production artifacts longer

  # Blue-Green Deployment Strategy
  deploy-blue-green:
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production-artifacts]
    if: needs.pre-deployment-validation.outputs.deployment-strategy == 'blue-green' && needs.pre-deployment-validation.outputs.project-type == 'fastapi'
    environment:
      name: production
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Deploy to blue environment
        run: |
          # Deploy to blue environment
          kubectl set image deployment/pa-qa-app-blue \
            pa-qa-app=${{ needs.build-production-artifacts.outputs.image-tag }} \
            -n production
          
          # Wait for blue deployment to be ready
          kubectl rollout status deployment/pa-qa-app-blue -n production --timeout=${DEPLOYMENT_TIMEOUT}s

      - name: Run health checks on blue environment
        run: |
          # Get blue service endpoint
          blue_endpoint=$(kubectl get service pa-qa-app-blue-service -n production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Comprehensive health checks
          echo "🔍 Running health checks on blue environment..."
          for i in {1..30}; do
            if curl -f -s "http://$blue_endpoint/health"; then
              echo "✅ Blue environment health check passed"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Blue environment health check failed"
              exit 1
            fi
            sleep 10
          done

      - name: Switch traffic to blue environment
        run: |
          # Update main service to point to blue deployment
          kubectl patch service pa-qa-app-service -n production \
            -p '{"spec":{"selector":{"version":"blue"}}}'
          
          echo "🔄 Traffic switched to blue environment"

      - name: Verify production traffic
        run: |
          # Verify production is serving from blue environment
          sleep 30
          prod_endpoint=$(kubectl get service pa-qa-app-service -n production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          for i in {1..10}; do
            if curl -f -s "http://$prod_endpoint/health"; then
              echo "✅ Production traffic verified on blue environment"
              break
            fi
            sleep 10
          done

  # Canary Deployment Strategy
  deploy-canary:
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production-artifacts]
    if: needs.pre-deployment-validation.outputs.deployment-strategy == 'canary' && needs.pre-deployment-validation.outputs.project-type == 'fastapi'
    environment:
      name: production
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Deploy canary version
        run: |
          # Deploy canary with limited replicas
          kubectl set image deployment/pa-qa-app-canary \
            pa-qa-app=${{ needs.build-production-artifacts.outputs.image-tag }} \
            -n production
          
          kubectl scale deployment pa-qa-app-canary --replicas=1 -n production
          kubectl rollout status deployment/pa-qa-app-canary -n production --timeout=${DEPLOYMENT_TIMEOUT}s

      - name: Configure canary traffic split
        run: |
          # Configure ingress/service mesh for canary traffic
          # This assumes you're using Istio, NGINX, or similar
          kubectl apply -f - << EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: pa-qa-app-canary
            namespace: production
          spec:
            hosts:
            - pa-qa-app.production.local
            http:
            - match:
              - headers:
                  canary:
                    exact: "true"
              route:
              - destination:
                  host: pa-qa-app-canary-service
            - route:
              - destination:
                  host: pa-qa-app-service
                weight: ${{ 100 - env.CANARY_PERCENTAGE }}
              - destination:
                  host: pa-qa-app-canary-service
                weight: ${{ env.CANARY_PERCENTAGE }}
          EOF

      - name: Monitor canary metrics
        run: |
          echo "📊 Monitoring canary deployment metrics for 10 minutes..."
          
          # Monitor metrics for 10 minutes
          for i in {1..60}; do
            # Get metrics from monitoring system (Prometheus, CloudWatch, etc.)
            error_rate=$(curl -s "${{ vars.MONITORING_API }}/query?query=error_rate_canary" | jq -r '.data.result[0].value[1] // "0"')
            response_time=$(curl -s "${{ vars.MONITORING_API }}/query?query=response_time_p95_canary" | jq -r '.data.result[0].value[1] // "0"')
            
            echo "Canary metrics - Error rate: ${error_rate}%, Response time P95: ${response_time}ms"
            
            # Check if metrics exceed thresholds
            if (( $(echo "$error_rate > 1.0" | bc -l) )); then
              echo "❌ Canary error rate too high: ${error_rate}%"
              exit 1
            fi
            
            if (( $(echo "$response_time > 1000" | bc -l) )); then
              echo "❌ Canary response time too high: ${response_time}ms"
              exit 1
            fi
            
            sleep 10
          done
          
          echo "✅ Canary metrics look good, proceeding with full deployment"

      - name: Promote canary to full deployment
        run: |
          # Scale up canary and scale down old version
          kubectl scale deployment pa-qa-app-canary --replicas=3 -n production
          kubectl scale deployment pa-qa-app --replicas=0 -n production
          
          # Update main service to point to canary
          kubectl patch service pa-qa-app-service -n production \
            -p '{"spec":{"selector":{"app":"pa-qa-app-canary"}}}'

  # Rolling Deployment Strategy (Default)
  deploy-rolling:
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production-artifacts]
    if: needs.pre-deployment-validation.outputs.deployment-strategy == 'rolling' || (needs.deploy-blue-green.result == 'skipped' && needs.deploy-canary.result == 'skipped')
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Deploy React to production CDN
        if: needs.pre-deployment-validation.outputs.project-type == 'react'
        id: deploy-react
        run: |
          # Download production build
          # This would typically involve uploading to CDN like CloudFront
          echo "🚀 Deploying React app to production CDN..."
          
          # Upload to S3/CloudFront
          aws s3 sync build/ s3://${{ vars.PRODUCTION_S3_BUCKET }}/ --delete
          aws cloudfront create-invalidation --distribution-id ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
          
          echo "url=https://${{ vars.PRODUCTION_DOMAIN }}" >> $GITHUB_OUTPUT

      - name: Deploy FastAPI to production cluster
        if: needs.pre-deployment-validation.outputs.project-type == 'fastapi'
        id: deploy-fastapi
        run: |
          # Setup kubectl
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME }}
          
          # Store current deployment for rollback
          current_image=$(kubectl get deployment pa-qa-app -n production -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "none")
          echo "Previous production image: $current_image"
          
          # Rolling update deployment
          kubectl set image deployment/pa-qa-app \
            pa-qa-app=${{ needs.build-production-artifacts.outputs.image-tag }} \
            -n production
          
          # Wait for rollout with extended timeout for production
          kubectl rollout status deployment/pa-qa-app -n production --timeout=${DEPLOYMENT_TIMEOUT}s
          
          # Get service URL
          service_url=$(kubectl get service pa-qa-app-service -n production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "url=https://$service_url" >> $GITHUB_OUTPUT
          
          # Store rollback information
          kubectl annotate deployment pa-qa-app -n production \
            rollback.image="$current_image" \
            deployment.version="${{ needs.pre-deployment-validation.outputs.version }}" \
            deployment.timestamp="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

      - name: Deploy WordPress to production
        if: needs.pre-deployment-validation.outputs.project-type == 'wordpress'
        id: deploy-wordpress
        run: |
          echo "🚀 Deploying WordPress to production..."
          
          # Create database backup before deployment
          wp db export backup-production-$(date +%Y%m%d-%H%M%S).sql \
            --host=${{ vars.WP_PROD_DB_HOST }} \
            --user=${{ secrets.WP_PROD_DB_USER }} \
            --password=${{ secrets.WP_PROD_DB_PASS }} \
            --path=${{ vars.WP_PROD_PATH }}
          
          # Deploy with zero-downtime strategy
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='wp-config.php' \
            --exclude='wp-content/uploads' \
            --temp-dir=/tmp/ \
            wordpress-production/ \
            ${{ secrets.WP_PROD_USER }}@${{ vars.WP_PROD_HOST }}:${{ vars.WP_PROD_PATH }}/
          
          echo "url=https://${{ vars.PRODUCTION_DOMAIN }}" >> $GITHUB_OUTPUT

      - name: Set deployment output
        id: deploy
        run: |
          if [ "${{ needs.pre-deployment-validation.outputs.project-type }}" == "react" ]; then
            echo "url=${{ steps.deploy-react.outputs.url }}" >> $GITHUB_OUTPUT
          elif [ "${{ needs.pre-deployment-validation.outputs.project-type }}" == "fastapi" ]; then
            echo "url=${{ steps.deploy-fastapi.outputs.url }}" >> $GITHUB_OUTPUT
          elif [ "${{ needs.pre-deployment-validation.outputs.project-type }}" == "wordpress" ]; then
            echo "url=${{ steps.deploy-wordpress.outputs.url }}" >> $GITHUB_OUTPUT
          fi

  comprehensive-health-checks:
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-blue-green, deploy-canary, deploy-rolling]
    if: always() && (needs.deploy-blue-green.result == 'success' || needs.deploy-canary.result == 'success' || needs.deploy-rolling.result == 'success')
    steps:
      - name: Get production URL
        id: url
        run: |
          if [ "${{ needs.deploy-rolling.outputs.url }}" != "" ]; then
            echo "url=${{ needs.deploy-rolling.outputs.url }}" >> $GITHUB_OUTPUT
          else
            echo "url=https://${{ vars.PRODUCTION_DOMAIN }}" >> $GITHUB_OUTPUT
          fi

      - name: Comprehensive health checks
        run: |
          url="${{ steps.url.outputs.url }}"
          echo "🔍 Running comprehensive production health checks for: $url"
          
          # Extended health check with retry
          max_attempts=60  # 10 minutes
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Health check attempt $attempt/$max_attempts..."
            
            if curl -f -s --max-time 30 "$url/health" > /dev/null; then
              echo "✅ Basic health check passed"
              break
            fi
            
            if [ $attempt -eq $max_attempts ]; then
              echo "❌ Health check failed after $max_attempts attempts"
              exit 1
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done

      - name: Run production smoke tests
        run: |
          url="${{ steps.url.outputs.url }}"
          echo "🧪 Running production smoke tests..."
          
          # Test critical endpoints
          endpoints=("/health" "/api/v1/status")
          if [ "${{ needs.pre-deployment-validation.outputs.project-type }}" == "fastapi" ]; then
            endpoints+=("/docs" "/metrics")
          fi
          
          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint..."
            if ! curl -f -s --max-time 30 "$url$endpoint" > /dev/null; then
              echo "❌ Endpoint $endpoint failed"
              exit 1
            fi
          done
          
          echo "✅ All smoke tests passed"

      - name: Performance validation
        run: |
          url="${{ steps.url.outputs.url }}"
          echo "⚡ Validating production performance..."
          
          # Test response times
          for i in {1..5}; do
            response_time=$(curl -o /dev/null -s -w "%{time_total}" "$url")
            echo "Response time $i: ${response_time}s"
            
            if (( $(echo "$response_time > 3.0" | bc -l) )); then
              echo "⚠️  WARNING: Slow response time: ${response_time}s"
            fi
          done

      - name: Security validation
        run: |
          url="${{ steps.url.outputs.url }}"
          echo "🔒 Running production security checks..."
          
          # Check security headers
          headers=$(curl -I -s "$url")
          
          security_headers=("X-Content-Type-Options" "X-Frame-Options" "X-XSS-Protection")
          for header in "${security_headers[@]}"; do
            if echo "$headers" | grep -qi "$header"; then
              echo "✅ Security header $header present"
            else
              echo "⚠️  WARNING: Missing security header $header"
            fi
          done

  post-deployment-monitoring:
    runs-on: ubuntu-latest
    needs: [comprehensive-health-checks]
    if: always() && needs.comprehensive-health-checks.result == 'success'
    steps:
      - name: Setup monitoring alerts
        run: |
          echo "📊 Configuring post-deployment monitoring..."
          
          # Enable enhanced monitoring for the next 24 hours
          curl -X POST "${{ vars.MONITORING_API }}/alerts/enhance" \
            -H "Authorization: Bearer ${{ secrets.MONITORING_TOKEN }}" \
            -d '{
              "duration": "24h",
              "version": "${{ needs.pre-deployment-validation.outputs.version }}",
              "deployment_time": "'$(date -u +'%Y-%m-%dT%H:%M:%SZ')'"
            }'

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          script: |
            // Create GitHub deployment record
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ needs.pre-deployment-validation.outputs.version }}',
              environment: 'production',
              description: 'Production deployment ${{ needs.pre-deployment-validation.outputs.version }}',
              auto_merge: false,
              required_contexts: []
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: '${{ needs.comprehensive-health-checks.outputs.url }}',
              description: 'Production deployment successful'
            });

      - name: Notify stakeholders
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#production-deployments'
          text: |
            🎉 Production deployment successful!
            
            **Version:** ${{ needs.pre-deployment-validation.outputs.version }}
            **Project:** ${{ needs.pre-deployment-validation.outputs.project-type }}
            **Strategy:** ${{ needs.pre-deployment-validation.outputs.deployment-strategy }}
            **URL:** ${{ needs.comprehensive-health-checks.outputs.url }}
            **Deployed by:** ${{ github.actor }}
            
            All health checks passed ✅
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # Emergency rollback capability
  emergency-rollback:
    runs-on: ubuntu-latest
    if: failure() && needs.pre-deployment-validation.outputs.is-rollback == 'false'
    needs: [pre-deployment-validation, comprehensive-health-checks]
    environment:
      name: production-emergency
    steps:
      - name: Emergency rollback
        run: |
          echo "🚨 EMERGENCY: Production deployment failed, initiating automatic rollback..."
          
          # Get last known good version
          last_good_version=$(curl -s "${{ vars.DEPLOYMENT_API }}/last-good-version" \
            -H "Authorization: Bearer ${{ secrets.DEPLOYMENT_TOKEN }}")
          
          if [ -n "$last_good_version" ] && [ "$last_good_version" != "null" ]; then
            echo "Rolling back to last known good version: $last_good_version"
            
            # Trigger emergency rollback
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/deploy-production.yml/dispatches" \
              -d "{
                \"ref\": \"main\",
                \"inputs\": {
                  \"rollback_version\": \"$last_good_version\",
                  \"bypass_approval\": \"true\"
                }
              }"
          else
            echo "❌ No previous version found for emergency rollback"
            echo "Manual intervention required!"
          fi

      - name: Alert on-call team
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#production-alerts'
          text: |
            🚨 PRODUCTION DEPLOYMENT FAILURE 🚨
            
            **Version:** ${{ needs.pre-deployment-validation.outputs.version }}
            **Failed at:** $(date -u)
            **Automatic rollback:** ${{ steps.emergency-rollback.outcome }}
            
            @channel - Immediate attention required!
          webhook_url: ${{ secrets.SLACK_EMERGENCY_WEBHOOK }}

      - name: Create incident
        run: |
          # Create incident in incident management system
          curl -X POST "${{ vars.INCIDENT_API }}/incidents" \
            -H "Authorization: Bearer ${{ secrets.INCIDENT_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Production Deployment Failure",
              "description": "Failed deployment of version ${{ needs.pre-deployment-validation.outputs.version }}",
              "severity": "high",
              "service": "pa-qa-app",
              "tags": ["deployment", "production", "failure"]
            }'